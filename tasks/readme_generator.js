// Generated by CoffeeScript 1.6.2
"use strict";module.exports = function(grunt) {
  var append, back_to_top, generate_TOC, generate_banner, generate_footer, generate_title, get_latest_changelog, make_anchor, pkg;

  pkg = require("./package.json");
  make_anchor = function(string) {
    var str;

    str = string.replace(/\s+/g, '-').toLowerCase();
    return str = "#" + str;
  };
  back_to_top = function() {
    var result, str;

    str = make_anchor(pkg.name);
    str += "-";
    return result = "[Back To Top](" + str + ")";
  };
  get_latest_changelog = function(prefix, changelog_folder) {};
  generate_banner = function(path, banner_file, output) {
    var f;

    f = path + "/" + banner_file;
    if (!grunt.file.exists(f)) {
      return grunt.log.error("Source file \"" + f + "\" not found.");
    } else {
      return grunt.file.write(output, grunt.file.read(f));
    }
  };
  generate_TOC = function(files, toc_extra_links, output) {
    var ex, file, i, link, title, _i, _len, _results;

    grunt.file.write(output, "## Jump to Section\n\n");
    for (file in files) {
      title = files[file];
      link = make_anchor(title);
      grunt.file.write(output, "* [" + title + "](" + link + ")\n");
    }
    if (toc_extra_links.length > 0) {
      _results = [];
      for (_i = 0, _len = toc_extra_links.length; _i < _len; _i++) {
        i = toc_extra_links[_i];
        ex = toc_extra_links[i];
        _results.push(grunt.file.write(output, "* " + ex + "\n"));
      }
      return _results;
    }
  };
  generate_title = function(output, travis) {
    var desc, title, ver;

    title = pkg.name;
    desc = pkg.description;
    ver = pkg.version;
    return grunt.file.write(output, "# " + title + "\n");
  };
  append = function(path, file, title, output) {
    var f, top;

    grunt.file.write(output, "## " + title + "\n");
    top = back_to_top();
    grunt.file.write(output, "" + top + "\n\n");
    f = path + "/" + file;
    if (!grunt.file.exists(f)) {
      return grunt.log.error("Source file \"" + f + "\" not found.");
    } else {
      return grunt.file.write(output, grunt.file.read(f));
    }
  };
  generate_footer = function(output) {
    var date, str;

    date = new Date();
    str = "--------\nThis readme has been automatically generated by [readme generator](https://github.com/aponxi/grunt-readme-generator) on " + date + ".";
    return grunt.file.write(output, str);
  };
  return grunt.registerMultiTask("readme_generator", "Generate Readme File", function() {
    var options;

    options = this.options({
      output: "README.md",
      table_of_contents: true,
      readme_folder: "readme",
      changelog_folder: "changelogs",
      changelog_version_prefix: "v",
      toc_extra_links: [],
      banner: null,
      has_travis: true
    });
    if (options.banner != null) {
      generate_banner(options.readme_folder, options.banner);
    }
    return this.files.forEach(function(f) {
      var src;

      src = f.src.filter(function(filepath) {
        if (!grunt.file.exists(filepath)) {
          grunt.log.error("Source file \"" + filepath + "\" not found.");
          return false;
        } else {
          return true;
        }
      }).map(function(filepath) {
        return grunt.file.read(filepath);
      }).join(grunt.util.normalizelf(options.separator));
      src += options.punctuation;
      grunt.file.write(f.dest, src);
      return grunt.log.writeln("File \"" + f.dest + "\" created.");
    });
  });
};
